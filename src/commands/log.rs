use chrono::Utc;
use std::env;
use std::os::unix::fs::MetadataExt;

use super::db::{CommandEntry, DatabaseManager};

fn get_session_id() -> String {
    // Try multiple methods to get a persistent session identifier
    
    // Method 1: Use XDG_SESSION_ID if available (systemd sessions)
    if let Ok(session_id) = env::var("XDG_SESSION_ID") {
        return format!("xdg:{}", session_id);
    }
    
    // Method 2: Check for terminal-specific session info
    // Use the controlling terminal which should be consistent for a session
    if let Ok(terminal) = std::fs::read_link("/proc/self/fd/0") {
        if let Some(term_name) = terminal.to_str() {
            if term_name.starts_with("/dev/") {
                let clean_name = term_name.replace("/dev/", "");
                // Get the terminal device stats for uniqueness
                if let Ok(metadata) = std::fs::metadata(term_name) {
                    // Use device ID + inode which should be unique per terminal session
                    return format!("term:{}:{}", clean_name, metadata.ino());
                }
                return format!("term:{}", clean_name);
            }
        }
    }
    
    // Method 3: Use process session ID from /proc/self/stat
    if let Ok(stat) = std::fs::read_to_string("/proc/self/stat") {
        let fields: Vec<&str> = stat.split_whitespace().collect();
        if fields.len() > 5 {
            // Field 5 (0-indexed) is the session ID - this should be consistent for a terminal session
            return format!("sid:{}", fields[5]);
        }
    }
    
    // Method 4: Use fish's process ID (if in fish shell)
    if let Ok(fish_pid) = env::var("fish_pid") {
        return format!("fish:{}", fish_pid);
    }
    
    // Method 5: Use shell-specific variables
    if let Ok(bash_pid) = env::var("BASHPID") {
        return format!("bash:{}", bash_pid);
    }
    
    // Method 6: Use TTY environment variable
    if let Ok(tty) = env::var("TTY") {
        return format!("tty:{}", tty.replace("/dev/", ""));
    }
    
    // Fallback: Create a session ID based on parent shell process
    let ppid = std::fs::read_to_string("/proc/self/stat")
        .ok()
        .and_then(|s| s.split_whitespace().nth(3).map(|s| s.to_string()))
        .unwrap_or_else(|| "unknown".to_string());
    
    format!("shell:{}", ppid)
}

pub async fn log_command(command: &str) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    let db_manager = DatabaseManager::new().await?;
    
    let entry = CommandEntry {
        id: None, // Will be auto-generated by database
        timestamp: Utc::now(),
        command: command.to_string(),
        user: env::var("USER").unwrap_or_else(|_| "unknown".to_string()),
        pwd: env::current_dir()
            .map(|p| p.display().to_string())
            .unwrap_or_else(|_| "unknown".to_string()),
        session_id: get_session_id(),
    };

    let row_id = db_manager.log_command(&entry).await?;
    
    println!("Command logged: {} (Session: {}, ID: {})", 
             command, entry.session_id, row_id);
    
    Ok(())
}
